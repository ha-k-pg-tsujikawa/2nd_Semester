メンバイニシャライザ → コンストラクタよりも前に実行される
						  ↓
					メンバ変数のコンストラクタ
あるクラスのコンストラクタの流れ
1.クラスのコンストラクタが呼び出される
2.メンバ変数のコンストラクタが呼び出される
3.クラスのコンストラクタ実行

メリット①処理の最適化
メリット②constメンバ変数を初期化できる
メリット③メンバ変数全体の初期値を把握しやすい

デフォルト引数は普段は一定の値だが
時々別の値が必要になるといった関数に行うとよい

int Sub(int a = 100, int b);
ans = Sub(200, 50);
ans = Sub(50);	→	Sub(100, 50);.Sub(50, ??);


インライン関数 → 処理の高速化の手段の1つ
関数へジャンプする必要がなくなる

関数の宣言部に定義を書くと、自動的にinline関数として扱われる
・インライン関数の注意点
関数の規模が大きいと判断されたものは、
例えinlineとついていても通常の関数呼び出しとして扱われる
そのため、inline関数の処理は小規模にしなければならない

メリット
高速化 → 関数呼び出しの負荷がなくなる → 例)for文で関数を読んでいる
デメリット
ファイルサイズが増える → ビルド時間が増える
隠蔽性が下がる
必ず展開されるとは限らない


後置const関数 → コンストメンバ関数 ← クラスの関数
関数の中でメンバ変数に変更がないことを保証する


explicit(明示的)
→コンストラクタに付ける
予期せぬ変換を防ぐ
explicitをつけない、引数が1つだけのコンストラクタ → 変換コンストラクタ


参照(Reference)
ポインタint* pInt;
参照	int& refInt;
アドレスを扱う
変数にアドレスをつけてアドレスを共有する
